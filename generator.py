import random
import pandas as pd
import numpy as np
from deap import base, creator, tools, algorithms
from file_reading import *

# Load data from CSV files
groups_df = pd.read_csv("CSV Files/Groups and Subjects (FAF Hack) - Grupe.csv")
subjects_df = pd.read_csv("CSV Files/Groups and Subjects (FAF Hack) - Subiecte.csv")
professors_df = pd.read_csv("CSV Files/Groups and Subjects (FAF Hack) - Profesori.csv")
classrooms_df = pd.read_csv("CSV Files/Groups and Subjects (FAF Hack) - Cabinete.csv")

# Define problem constants
NUM_DAYS = 5  # Number of days in a week
NUM_SLOTS_PER_DAY = 7  # Number of time slots per day

# Define the genetic algorithm parameters
POPULATION_SIZE = 50
CROSSOVER_PROBABILITY = 0.8
MUTATION_PROBABILITY = 0.2
NUM_GENERATIONS = 100

def evaluate(individual):
    fitness_value = 0.0

    # Extract genes from the individual
    group_id, subject_id, professor_id, classroom_id, day, slot = individual

    # Retrieve data for the current genes
    group_info = groups_df.loc[groups_df['id'] == group_id].iloc[0]
    subject_info = subjects_df.loc[subjects_df['id'] == subject_id].iloc[0]
    professor_info = professors_df.loc[professors_df['id'] == professor_id].iloc[0]
    classroom_info = classrooms_df.loc[classrooms_df['id'] == classroom_id].iloc[0]

    # Check classroom availability and dimensions
    if not classroom_info['is_lab_cab'] and subject_info['lab'] > 0:
        # Penalty for scheduling a lab in a non-lab classroom
        fitness_value -= 1000
    elif classroom_info['nr_persons'] < group_info['nr_persoane']:
        # Penalty for scheduling in a classroom with insufficient capacity
        fitness_value -= 500

    # Check teachers' preferences
    if professor_info[f"{day}_per_{slot}"] == 0:
        # Penalty for scheduling a lesson when the professor is not available
        fitness_value -= 1000

    # Check language of the subject
    if group_info['language'] != subject_info['language']:
        # Penalty for scheduling a subject in a different language
        fitness_value -= 1000

    # Apply additional constraints and penalties as needed

    return fitness_value,


# Create types for individuals and fitness
creator.create("FitnessMulti", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMulti)

# Initialize the genetic algorithm toolbox
toolbox = base.Toolbox()

# Define the gene attributes
toolbox.register("groups", random.sample, groups_df["id"].tolist(), len(groups_df))
toolbox.register("subjects", random.sample, subjects_df["id"].tolist(), len(subjects_df))
toolbox.register("professors", random.sample, professors_df["id"].tolist(), len(professors_df))
toolbox.register("classrooms", random.sample, classrooms_df.columns.tolist(), len(classrooms_df.columns))

# Define the individual as a list of genes (group, subject, professor, classroom, day, slot)
toolbox.register("individual", tools.initCycle, creator.Individual,
                 (toolbox.groups, toolbox.subjects, toolbox.professors, toolbox.classrooms),
                 n=1)

# Define the population
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# Define the evaluation function
def evaluate(individual):
    # Implement your evaluation function here
    # Check for constraints: classroom availability, teacher preferences, time constraints, etc.
    # Return a fitness value based on how well the individual satisfies the constraints
    fitness_value = 0.0
    return fitness_value,

toolbox.register("evaluate", evaluate)

# Define the crossover and mutation operations
toolbox.register("mate", tools.cxOnePoint)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.1)

# Define the selection operator
toolbox.register("select", tools.selTournament, tournsize=3)

# Create an initial population
population = toolbox.population(n=POPULATION_SIZE)

# Run the genetic algorithm
algorithms.eaMuPlusLambda(population, toolbox, mu=POPULATION_SIZE, lambda_=2*POPULATION_SIZE,
                          cxpb=CROSSOVER_PROBABILITY, mutpb=MUTATION_PROBABILITY, ngen=NUM_GENERATIONS,
                          stats=None, halloffame=None, verbose=True)

# Retrieve the best individual
best_individual = tools.selBest(population, k=1)[0]

# Print the schedule generated by the algorithm
print("Best Schedule:")
for gene in best_individual:
    print(gene)
